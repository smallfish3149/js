数据类型：
                    分类：
                            基本数据类型：string、number、boolean、undefined、null
                            对象类型(引用)：Object、Function(特别的对象，可以执行)、Array(特别的对象，有数值下标，有序)
                    判断：
                            typeof      返回数据类型的字符串表达，例如：'undefine'
                                                          可以判断undefined、数值、字符串、布尔值
                                                          不能判断null和object、array和object
                            instanceof          判断对象的数据类型
                            ===                     可以判断undefined、null

                    undefined和null的区别：
                                undefined:定义了未赋值
                                null:定义并赋值，但是值是null
                    什么时候给变量赋值未null：
                                初始赋值，表面即将赋值未对象。
                                使用完了对象，把对象赋值为null成为垃圾对象，被垃圾回收回收
                    严格区分变量类型和数据类型：
                                js是弱类型，var a；a的类型是var，变量存放的是变量内存值的类型
                                        数据类型：
                                                            基本数据类型
                                                            对象类型
                                        变量的类型：
                                                            基本类型：保存的是基本数据类型的数据
                                                            引用类型：保存的地址值
                    数据、变量、内存：
                        什么是数据：
                                存储内存中代表特定信息的
                                数据的特点：
                                                        可传递
                                                        可运算
                                                        一切皆数据
                                                        内存中所有操作的目标:数据
                                                                算术运算
                                                                逻辑运算
                                                                赋值运算
                                                                运行函数
                        什么是变量：
                                可变化的量，由变量名、变量值组成。每个变量都对应一块小内存。变量名用来查找对应的内存，变量值就是内存中保存的数据。
                        什么是内存：
                                内存条通电之后产生的可存储数据空间(临时)
                                一小块内存的两个数据：内部存储的数据、地址值
                                内存分类：
                                        栈:全局变量、局部变量
                                        堆:对象
                        内存、数据、变量三者之间的关系:
                                内存是用来存储数据的空间
                                变量是内存的标识
            相关问题：
                        赋值和内存
                                2个引用变量指向同一个对象，一个变量修改对象内部数据，另外一个变量看到的是修改之后的数据
                                2个引用变量指向同一个对象，一个引用变量指向另一个对象，另一个引用变量依然指向原来的对象
                        数据传递
                                在js调用函数是传递变量参数时，是值传递还是引用传递:
                                        理解1：都是值(基本/地址值)
                                        理解2:：可能是值传递，也可能是引用传递
                        JS引擎如何管理内存
                                内存声明周期
                                        分配内存空间，得到内存使用权
                                        存储数据，可以反复进行操作
                                        释放内存空间
                                释放内存
                                        局部变量：函数执行完自动释放
                                        对象：成为垃圾对象，由垃圾回收器回收
对象：
                什么是对象？
                                多个数据的封装体
                                用来保存多个数据的容器
                                一个对象代表现实中的一个事物
                为什么要用对象？
                                统一管理多个数据
                对象的组成
                                属性：属性名(字符串)、属性值(任意类型)
                                方法：一种特别的属性(属性值是函数)
                如何访问对象内部数据？
                                .属性名                                 编码简单，有时不能用
                                对象['属性名']                          编码麻烦，通用
                        什么时候必须使用['属性名'] 方式访问对象内部数据？
                                属性名包括特殊字符，例如- 空格
                                属性名不确定
函数：
                什么是函数？
                                实现特点功能的n条语句的封装体
                                只有函数是可执行的，其他类型的数据不能执行
                为什么要用函数？
                                提高代码复用
                                便于阅读交流
                如何定义函数？
                                        函数声明方式
                                        function fn1(){
                                                
                                        }
                                        表达式方式
                                        var fn2 = function (){

                                        }
                如何调用函数？
                        直接调用
                        通过对象方式调用
                        new调用
                        test.call/apply(obj)                    临时让test成为obj的方法进行调用，可以让一个函数成为指定任意对象的方法进行调用

回调函数：
                什么函数才是回调函数？
                                你定义的
                                你没有调用
                                但最终执行了
                常见的回调函数
                                dom事件回调函数
                                定时器回调函数
                                ajax请求回调函数
                                生命周期回调函数
IIFE
                立即执行函数表达式

                (function (){                           //匿名函数自调用
                        console.log('000');
                })()
                作用：
                                隐藏实现
                                不会污染外部(全局)命名空间
                                用它来编写js模块
                (function (){
                        var a = 1;
                        function test(){
                                console.log(++a);
                        }
                        window.$ = function(){                  //向外暴露一个函数
                                return {test:test}
                        }
                })()；

                $().test()              $是一个函数     $执行后返回的是一个对象

函数中的this：
                this是什么
                                所有函数内部都有一个变量this
                                它的值是调用函数的当前对象
                如何确定this的值
                        任何函数本质上都是通过某个对象来调用的，如果没有指定，就是window
语句是否该用分号：
        可用可不用，编码习惯问题，有两种情况必须加分号的：
                                                                                                        小括号前面
                                                                                                        中方括号前面
                                                                                        解决办法，在行首加分号

函数高级：
                函数的prototype属性
                                每一个函数都有prototype属性，它默认指向一个object空对象
                                原型对象中有一个属性constructor，它指向函数对象
                显式原型和隐式原型：
                                

原型链：尽头是object的原型对象
                1.访问一个对象属性时
                        先在自身属性中查找，找到返回
                        如果没有，再沿着__proto__这条链向上查找，找到返回
                        如果没有找到，就返回undefined
                别名：隐式原型链
                作用：查找对象属性
                实例对象隐性原型的值等于构造函数的显式原型的值
                所有函数对象都有一个隐式原型，指向Function显式原型
                所以函数的隐式原型(__proto__)都是一样的

                函数的显式原型指向的对象默认是空的Object实例对象，但Object不满足
                所有函数都是Function的实例，包括Function
原型链属性问题：
                1.读取对象的属性值时，会自动到原型链中查找
                2.设置对象属性值时，不会查找原型链，如果当前对象中没有此属性，直接添加属性并赋值
                3.方法一般定义在原型中，属性一般通过构造函数对象定义在对象本身
探索instanceof：
                1.instanceof是如何判断的
                        表达式：A instanceof B
                        如果B函数的显式原型对象在A对象原型上，返回true，否则返回false
                Function是通过自己产生的实例

执行上下文与上下文栈

        变量提升与函数提升
                变量声明提前：通过var声明的变量，在定义语句之前就可以找到值：undefined
                函数声明提前：通过function声明的函数，在之前就可以直接调用

                变量声明和函数提前是如何产生的：

        代码分类：
                                全局代码
                                函数代码(局部代码)

        全局执行上下文：
                                在执行代码前，将window确定为全局执行上下文
                                对全局数据进行预处理
                                        var定义的全局变量==》undefined，添加为window属性
                                        function声明的函数==》赋值，添加为window方法
                                        this==》window
                                开始执行全局代码
        函数执行上下文：
                                在调用函数，准备函数体之前，创建对应的函数执行上下文对象
                                对局部数据进行预处理：
                                        形参变量==》赋值(实参)，添加为执行上下文属性
                                        argument==》赋值(实参列表)，添加为执行上下文属性
                                        var定义的局部变量==》undefined，添加为执行上下文的属性
                                        function声明的函数==》赋值，添加为执行上下文方法
                                        this==》赋值(调用函数的对象)
                                开始执行函数体代码
        执行上下文栈：
                                在执行代码前，js引擎就会创建一个栈来存储管理所以的执行上下文对象
                                在全局执行上下文(window)确定之后，将window压到栈中
                                函数执行上下文创建后，将其压到栈中
                                在对象执行上下文后，将栈顶的对象移除
                                当所有的代码执行完，栈中只有window
递归调用：在函数内部调用自己
先执行变量提升，再执行函数提升

作用域与作用域链
        1.理解：
                        就是一块地盘，一个代码段所在的一个区域
                        他是静态的(相对一执行上下文对象)，在编写代码时就确定了
        2.分类
                        全局作用域
                        函数作用域
                        没有块作用域(ES6有了)
        3.作用
                        隔离变量，不同作用域下同名变量不会冲突
闭包：
                如何产生闭包？
                        当一个嵌套的内部(子)函数引用了嵌套外部(父)函数时，产生了闭包
                闭包到底是什么？
                        理解一：闭包是嵌套的内部函数(绝大多数人)
                        理解二：包含被引用变量(函数)的对象(极少数人)
                        注意：闭包存在于嵌套的内部函数中
                产生闭包的条件：
                        函数嵌套
                        内部函数引用了外部函数的数据(变量/函数)
        常见的闭包：
        闭包的作用：
                                        使用函数内部的变量在函数执行完后，仍然存辉在内存中(延迟了局部变量的声明周期)
                                        让外部函数可以操作(读写)到函数内部的数据(变量/函数)

                                问题：
                                        函数执行完后，函数内部声明的局部变量是否存在？          一般不存在，存在于闭包中的变量才可能存在
                                        函数外部能直接访问函数内部的局部变量吗？                        不能，但是通过闭包让外部操作它
                闭包的生命周期：
                                                        产生：在嵌套内部函数定义执行完成时就产生了(不是调用)
                                                                                function fun1(){
                                                                                        //此时已经产生闭包了，函数提升，内部函数对象已经创建
                                                                                        var a=2
                                                                                        function fun2(){
                                                                                                a++
                                                                                                console.log(a)
                                                                                        }
                                                                                        return fun2
                                                                                }
                                                                                var f = fun1
                                                                                f()
                                                                                f()
                                                                                f = null        //闭包死亡，包含闭包的对象成为垃圾对象
                                                        死亡：在嵌套内部函数成为垃圾对象时
闭包的应用：
                定义js模块：
                                具有特定功能的js文件
                                将所有的数据和功能都封装在一个函数内部(私有的)
                                只向外暴露一个包含n个方法的对象或函数
                                        (function (){
                                                var smallfish = 'smallfish'
                                                function doSomething(){
                                                        console.log('doSomething()'+smallfish.toUpperCase())
                                                }
                                                function doOtherthing(){
                                                        console.log('doOtherthing()'+smallfish.toLowerCase())
                                                }
                                                window.smallfish={
                                                        doSomething:doSomething
                                                        doOtherthing:doOtherthing
                                                }
                                        })()
                                        这种方法更好，不用调用函数，直接把要暴露的函数设为window的对象，引入js文件就能得到想要的东西
                                模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能
闭包的缺点:
                函数执行完之后，，函数内的局部变量没有释放，占用内存时间会边长
                容易造成内存泄露

                如果解决？
                        能不用闭包就不用闭包，及时释放
内存溢出
                一种程序运行出现的错误，当程序需要的内存超过剩余内存时，就会跑出内存溢出的错误
内存泄露
                占用内存没有及时释放
                内存泄露积累多了就容易造成内存溢出
        常见的内存溢出：
                                意外的全局变量
                                没有及时清理计时器或回调函数
                                闭包

#面向对象高级

方式一:Object构造函数模式：
        套路：先创建空的Object对象，再动态添加属性/方法
        适用场景：起始时不确定对象内部数据
        问题：语句太多
方式二：字面量模式
        套路：使用{}创建对象，同时指定属性/方法
        适用场景：起始时对象内部数据确定的
        问题：如果创建多个对象，有重复代码
方式三：工厂模式
        套路：通过工厂函数动态创建对象并返回
        适用场景：需要创建多个对象
        问题：对象没有一个具体类型，都是object
方式四：自定义构造函数模式
        套路：自定义构造函数，通过new创建对象
        适用场景：需要创建多个类型确定的对象
        问题：每个对象都有相同的数据，浪费内存
方式五：构造函数+原型的组合模式
        套路：自定义构造函数，属性在函数中初始化，方法添加到原型上
        适用场景：需要创建多个类型确定的对象

继承模式：
        原型链继承：
                        套路：
                                        定义父类型构造函数
                                        给父类型的原型添加方法
                                        定义子类型的构造函数
                                        创建父类型的对象赋予子类型的原型
                                        将子类型的原型构造函数设置为子类型
                                        给子类型原型添加方法
                                        创建子类型的对象：可以调用父类型的方法
                        关键：子类型的原型为父类型的一个实例对象
组合继承：
                原型链+借用构造函数的组合继承



jQuery属性：
                                                // 1. 读取第一个div的title属性
                                                //console.log($('div:first').attr("title"))
                                                // 2. 给所有的div设置name属性(value为atguigu)
                                                //$('div').attr("name","smallfish")
                                                // 3. 移除所有div的title属性
                                                //$('div').remove("title")
                                                // 4. 给所有的div设置class='guiguClass'
                                                //$('div').attr("class","smallfish")
                                                // 5. 给所有的div添加class='abc'
                                                //$('div').addClass("abc")
                                                // 6. 移除所有div的guiguClass的class
                                                //$('div').removeClass("smallfish")
                                                // 7. 得到最后一个li的标签体文本
                                                //console.log($('li:last').html())
                                                // 8. 设置第一个li的标签体为"<h1>mmmmmmmmm</h1>"
                                                //$('li:first').html("<h1>mmmmmmmmm</h1>")
                                                // 9. 得到输入框中的value值
                                                //console.log($(':text').val())
                                                // 10. 将输入框的值设置为atguigu
                                                //$(':text').val("smallfish")
                                                // 11. 点击'全选'按钮实现全选
                                                $('button:first').click(function (){
                                                $(':checkbox').prop("checked",true)
                                                })
                                                // 12. 点击'全不选'按钮实现全不选
                                                $('button:last').click(function (){
                                                $(':checkbox').prop("checked",false)
                                                })